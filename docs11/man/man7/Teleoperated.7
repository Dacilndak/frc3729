.TH "RJFRC2011::Teleoperated" 7 "Mon May 30 2011" "RJHS FRC Software Documentation" \" -*- nroff -*-
.ad l
.nh
.SH NAME
RJFRC2011::Teleoperated \- 
.PP
Class managing robot performance in \fBTeleoperated\fP mode.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Teleoperated.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBTeleoperated\fP (\fBDrive\fP *drive, \fBManipulator\fP *manip, \fBController\fP *controller, DriverStationLCD *screen)"
.br
.RI "\fIConstruct from the addresses of a drive system, a manipulator, a controller, and the driver station LCD screen. \fP"
.ti -1c
.RI "\fB~Teleoperated\fP ()"
.br
.RI "\fIDestructor. Kill stuff. \fP"
.ti -1c
.RI "void \fBInit\fP ()"
.br
.RI "\fISet up for \fBTeleoperated\fP mode. \fP"
.ti -1c
.RI "void \fBGo\fP ()"
.br
.RI "\fIThis is where the magic happens. Get driver input, then figure out what to do with it. \fP"
.ti -1c
.RI "void \fBtestLimitSwitches\fP ()"
.br
.RI "\fIPrint the values we're getting from the limit switches to the screen. \fP"
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "\fBDrive\fP * \fB_drive\fP"
.br
.RI "\fIPointer to object abstracting drive system. \fP"
.ti -1c
.RI "\fBManipulator\fP * \fB_manip\fP"
.br
.RI "\fIPointer to object abstracting manipulator. \fP"
.ti -1c
.RI "\fBController\fP * \fB_controller\fP"
.br
.RI "\fIPointer to object abstracting controller. \fP"
.ti -1c
.RI "DriverStationLCD * \fB_screen\fP"
.br
.RI "\fIThe screen of the driver station. \fP"
.ti -1c
.RI "Relay * \fBminibotShelf\fP"
.br
.RI "\fIThe minibot shelf relay. \fP"
.ti -1c
.RI "DigitalInput * \fBtop\fP"
.br
.RI "\fITop manipulator limit switch. \fP"
.ti -1c
.RI "DigitalInput * \fBbottom\fP"
.br
.RI "\fIBottom manipulator limit switch. \fP"
.ti -1c
.RI "float \fBmanipulatorElevation\fP"
.br
.RI "\fIUser input: requested manipulator elevation. \fP"
.ti -1c
.RI "float \fBdriveSpeed\fP"
.br
.RI "\fIUser input: requested drive speed. \fP"
.ti -1c
.RI "float \fBdriveTurn\fP"
.br
.RI "\fIUser input: requested drive turn. \fP"
.ti -1c
.RI "int \fBmanipulatorAction\fP"
.br
.RI "\fIUser input: requested manipulator action. \fP"
.ti -1c
.RI "int \fBminibotSwitches\fP"
.br
.RI "\fIUser input: requested minibot switches. \fP"
.ti -1c
.RI "int \fB_nextState\fP"
.br
.RI "\fIUsed internally (in \fIgenericCondition()\fP) to manage state switching. \fP"
.ti -1c
.RI "bool \fBrotateTubeDownFlag\fP"
.br
.RI "\fIUsed to flag that we want to rotate the tube down (after inputting it) \fP"
.in -1c
.SH "Detailed Description"
.PP 
Class managing robot performance in \fBTeleoperated\fP mode. 

Gets user input from two controllers (abstracted as instances of class \fIJoystick\fP), processes said inputs (normalizing joystick values, dead space, etc.), and feeds them to a series of outputs (mainly the \fI\fBDrive\fP\fP class). 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "RJFRC2011::Teleoperated::Teleoperated (\fBDrive\fP *drive, \fBManipulator\fP *manip, \fBController\fP *controller, DriverStationLCD *screen)"
.PP
Construct from the addresses of a drive system, a manipulator, a controller, and the driver station LCD screen. Set up pointers to passed adresses. Initialize state and condition pointers. 
.SH "Member Function Documentation"
.PP 
.SS "void RJFRC2011::Teleoperated::Go ()"
.PP
This is where the magic happens. Get driver input, then figure out what to do with it. Get input from the controller (see \fI\fBController\fP\fP class). Based on this, decide what values to send to the \fI\fBDrive\fP\fP class and \fI\fBManipulator\fP\fP class, as well as how to move the relay (\fIRelay\fP class) controlling the minibot deployment system. 

.SH "Author"
.PP 
Generated automatically by Doxygen for RJHS FRC Software Documentation from the source code.
