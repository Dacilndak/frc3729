/*!
 \file BuiltinDefaultCode.cpp
 \brief The file containing the class BuiltinDefaultCode.  We didn't bother changing the name...
 
 */

#include "macros.h"
#include "WPILib.h"
#include "Autonomous.h"
#include "Teleoperated.h"
#include "Controller.h"
using namespace RJFRC2011;

/*! \class BuiltinDefaultCode : public IterativeRobot
 \brief Our big class that does everything.  We didn't bother renaming it.
 
 For those of you reading this who are unfamiliar with C++, this 'class' actually abstracts all of the features of a robot.  For example, on line 45 we give it a drive system.  On line 66 we connect it to a driver station (or, at least, say that we will later on).
 */
class BuiltinDefaultCode : public IterativeRobot
{
private:
	//! Class abstracting drive system
	Drive * drive;
	
	//! Class abstracting manipulator
	Manipulator * manipulator;
	
	//! Forwards/backwards relay controlling minobot shelf extension
	Relay * minibotShelf;
	
	//! Object abstracting the driver station
	DriverStation * ds;
	
	//! Object interfacing with a controller connected to a USB port on the classmate laptop (AKA the driver station)
	Controller *controller;
	
	// State machine variables
	//! Autonomous state machine
	Autonomous * auto_machine;
	//! Teleoperated state machine
	Teleoperated * teleop_machine;
	
public:
	/*!
	 * \brief Constructor for this "BuiltinDefaultCode" Class.
	 * 
	 * The constructor creates all of the objects used for the different inputs and outputs of
	 * the robot.  Essentially, the constructor defines the input/output mapping for the robot,
	 * providing named objects for each of the robot interfaces. 
	 */
	BuiltinDefaultCode(void)
	{
		// Set up relays
		minibotShelf = new Relay(MINIBOT_SHELF_RELAY_PORT, Relay::kBothDirections);
		
		drive = new Drive();
		manipulator = new Manipulator();
		controller = new Controller();
		
		// Set up state machines
		auto_machine = new Autonomous(drive, manipulator, controller);
		teleop_machine = new Teleoperated(drive, manipulator, controller);
		
		// Acquire the Driver Station object
		ds = DriverStation::GetInstance();
	}
	
	//! Destructor.  Called when a class object expires.  Used so we don't waste memory.
	~BuiltinDefaultCode()
	{
		delete auto_machine;
		delete teleop_machine;
		delete drive;
		delete controller;
		delete minibotShelf;
	}
	
	//! Clean up at end of match.
	void RJRobotEnd(void)
	{
		/*
		GetWatchdog().SetExpiration(3.0);
		minibotShelf->Set(Relay::kReverse);
		Wait(2);
		minibotShelf->Set(Relay::kOff);
		manipulatorElevation->Set(Relay::kReverse);
		while (manipulatorElevationBottomLimitSwitch->Get() != 1) { continue; }
		manipulatorElevation->Set(Relay::kOff);
		manipulatorTop->Set(Relay::kOff);
		manipulatorBottom->Set(Relay::kOff);
		drive->Drive(0, 0);
		*/
	}
	
	/********************************** Init Routines *************************************/
	
	//! Actions which would be performed once (and only once) upon initialization of the robot are put here
	void RobotInit(void)
	{
		GetWatchdog().SetExpiration(DEFAULT_WATCHDOG_TIME);
		// Actions which would be performed once (and only once) upon initialization of the
		// robot would be put here.
	}
	
	//! Code called at the beginning of Disabled Mode
	void DisabledInit(void)
	{
		GetWatchdog().Feed();
	}
	
	//! Code called at the beginning of Autonomous Mode
	void AutonomousInit(void)
	{
		GetWatchdog().Feed();
		auto_machine->setState(0);
	}
	
	//! Code called at the beginning of Teleoperated Mode
	void TeleopInit(void)
	{
		GetWatchdog().Feed();
		Teleoperated.setState(0);
	}
	
	/********************************** Periodic Routines *************************************/
	
	//! The code called in a loop during Disabled Mode.  Left as the default, minus the loop counter.
	void DisabledPeriodic(void)
	{
		GetWatchdog().Feed();
		// Basically, sit idle and keep the watchdog running.
	}
	
	//! The code called in a loop during Autonomous Mode
	void AutonomousPeriodic(void)
	{
		GetWatchdog().Feed();
		auto_machine->Go();
		auto_machine->Next();
	}
	
	//! The code called in a loop during Teleoperated Mode
	void TeleopPeriodic(void)
	{
		GetWatchdog().Feed();
		teleop_machine->Go();
		teleop_machine->Next();
		
		// manipulator controls
		if (x_r > 0.35)
		{
			// input tube
		}
		else if (x_r < -0.35)
		{
			// eject tube
		}
		else if ((x_r < 0.35) && (x_r > -0.35))
		{
			manipulatorBottom->Set(Relay::kOff);		// turn things off
			manipulatorTop->Set(Relay::kOff);			// ditto
		}
		
		
		if (ManipulatorDownFlag == true && (x_r < 0.35) && (x_r > -0.35))	// go here ONLY if user has flagged that tube is ready AND the relays are off (done inputting; right joystick has zero X)
		{
			// rotate tube down
		}
		
		// minibot controls
		if (rightSwitch == 1 && leftSwitch == 0)		// 10
		{
			minibotShelf->Set(Relay::kForward);			// Set the relay to forward if the right switch is on...
		}
		else if (leftSwitch == 1 && rightSwitch == 0)	// 01
		{
			minibotShelf->Set(Relay::kReverse);			// ...forward if the left switch is on...
		}
		else if (rightSwitch == 0 && leftSwitch == 0)	// 00
		{
			minibotShelf->Set(Relay::kOff);				// ..or off if the switch is off
		}
		else											// 11
		{
			minibotShelf->Set(Relay::kOff);
		}
		// We back up the shelf in the destructor
		
		// set previous left X and Y values (for ramping function)
		x_l_prev = x_l;
		y_l_prev = y_l;
		Wait(0.1);
	}
	
	//! A function that "ramps" input from a joystick to motors so that an overzealous driver doesn't tear up the chassis
	/*!
	 \param desired_output The output that the operator is trying to send
	 \param current_output The current output
	 \param increment The amount by which to increment ramping.  Defaults to .005
	 \return the ramped value
	 \author Drew Lazzeri
	 */
	float ramp(float desired_output, float current_output)
	{
		float increment = .1;
		if (desired_output  <= .1 && desired_output >= -.1);
		    increment = .05;
		if (desired_output < current_output)
		{
			return current_output - increment;//(desired_output * increment);
		}    
		else if (desired_output > current_output)
		{    
			return /*(desired_output * increment)*/increment + current_output;
		}
		else
		{
			return current_output;
		}
	}
};

START_ROBOT_CLASS(BuiltinDefaultCode);
