/*!
 \file BuiltinDefaultCode.cpp
 \brief The file containing the class BuiltinDefaultCode.  We didn't bother changing the name...
 
 */

// NOTICE: We've decided agianst the CAN network, as it would take a while to set up and we don't need those 4 extra PWM ports for anything else anyway.
/*
// Adjustment macros by Adam Bryant
//! Adjustment for the fact that the joystick is slightly off-center
#define YCENTER (0.03125)

//! Adjustment for the fact that the joystick is slightly off-center
#define ROTCENTER (0.0156)
//! Minimum possible X value
#define XMIN -0.641
//! Maximum possible X value
#define XMAX 0.648
//! Minimum possible Y value
#define YMIN (-0.57-YCENTER)
//! Maximum possilble Y value
#define YMAX (0.641-YCENTER)
//! Minimum possible Z value
#define ZMIN (-0.54)
//! Maximum possible Z value
#define ZMAX (0.63)
//! Minimum possible rotation value
#define ROTMIN (-0.64-ROTCENTER)
//! Maximum possible rotation value
#define ROTMAX (0.68-ROTCENTER)
//! Exponential constant for modifying input from the x-axis
#define XEXPO 0.4
//! Exponential constant for modfying input from the y-axis
#define YEXPO 0.4
//! Exponential constant for modifying input form the rotational axis
#define ROTEXPO 0.6

// Port # constants: Digital I/O
//! Port # for the physical lane choosing switch in Autonomous.  ALSO: Is using this switch really necessary?  Could we just hard-code the thing?
#define AUTONOMOUS_LANE_SWITCH_PORT 6
//! Port # for the physical fork choosing switch in Autonomous.  ALSO: Is using this switch really necessary?  Could we just hard-code the thing?
#define AUTONOMOUS_FORK_SWITCH_PORT 7
//! Port # for the relay controlling the minbot shelf
#define MINIBOT_SHELF_RELAY_PORT 1
//! Port # for the relay controlling the top wheels of the manipulator
#define MANIPULATOR_TOP_RELAY_PORT 2
//! Port # for the relay controlling the bottom wheels of the manipulator
#define MANIPULATOR_BOTTOM_RELAY_PORT 3
//! Port # for the relay controlling elevation of the manipulator
#define MANIPULATOR_ELEVATION_RELAY_PORT 4
//! Port # for the limit switch at the top of the manipulator elevator's reach.  ALSO: Is using this really necessary?  Could it just be operator-controlled?  Less safe that way, but simpler...
#define MANIPULATOR_ELEVATION_TOP_LIMIT_SWITCH_PORT	4
//! Port # for the limit switch at the bottom of the manipulator elevator's reach.  ALSO: Is using this really necessary?  Could it just be operator-controlled?  Less safe that way, but simpler...
#define MANIPULATOR_ELEVATION_BOTTOM_LIMIT_SWITCH_PORT 5
//! Port # of the leftmost line-following light sensor
#define LIGHT_SENSOR_LEFT_PORT 1
//! Port # of the center line-following light sensor
#define LIGHT_SENSOR_CENTER_PORT 2
//! Port # of the rightmost line-following light sensor
#define LIGHT_SENSOR_RIGHT_PORT	3

// Port # constants: PWM out
//! Port # of the front left Jaguar on the drive train
#define DRIVE_FRONT_LEFT_JAGUAR_PORT 5
//! Port # of the front right Jaguar on the drive train
#define DRIVE_FRONT_RIGHT_JAGUAR_PORT 7
//! Port # of the back left Jaguar on the drive train
#define DRIVE_BACK_LEFT_JAGUAR_PORT	6
//! Port # of the back right Jaguar on the drive train
#define DRIVE_BACK_RIGHT_JAGUAR_PORT 8

// Others
//! The default expiration time of the Watchdog timer, in seconds
#define DEFAULT_WATCHDOG_TIME (0.75)
*/

#include "macros.h"
#include "WPILib.h"
#include "Autonomous.h"
#include "Teleoperated.h"
using namespace RJFRC2011;

/*! \class BuiltinDefaultCode : public IterativeRobot
 \brief Our big class that does everything.  We didn't bother renaming it.
 
 For those of you reading this who are unfamiliar with C++, this 'class' actually abstracts all of the features of a robot.  For example, on line 45 we give it a drive system.  On line 66 we connect it to a driver station (or, at least, say that we will later on).
 */
class BuiltinDefaultCode : public IterativeRobot
{
private:
	//! Class abstracting drive system
	Drive * drive;
	
	//! Forwards/backwards relay controlling minobot shelf extension
	Relay * minibotShelf;
	
	//! Object abstracting the driver station
	DriverStation * ds;
	
	//! Object interfacing with a controller connected to a USB port on the classmate laptop (AKA the driver station)
	Joystick *controller;
	
	// State machine variables
	//! Autonomous state machine
	Autonomous * auto_machine;
	//! Teleoperated state machine
	Teleoperated * teleop_machine;
	
	// Teleoperated variables
	//! X value read by controller (left stick)
	float x_l;
	float x_l_prev;
	//! Y value read by controller (left stick)
	float y_l;
	float y_l_prev;
	//! X value read by controller (right stick)
	float x_r;
	//! Y value read by controller (right stick)
	float y_r;
	//! Value of left trigger switch
	UINT8 leftSwitch;
	//! Value of right trigger switch
	UINT8 rightSwitch;
	//! Keep track of when to rotate the tube down
	bool ManipulatorDownFlag;
	
public:
	/*!
	 * \brief Constructor for this "BuiltinDefaultCode" Class.
	 * 
	 * The constructor creates all of the objects used for the different inputs and outputs of
	 * the robot.  Essentially, the constructor defines the input/output mapping for the robot,
	 * providing named objects for each of the robot interfaces. 
	 */
	BuiltinDefaultCode(void)
	{
		// Set up relays
		minibotShelf = new Relay(MINIBOT_SHELF_RELAY_PORT, Relay::kBothDirections);
		
		// Acquire the Driver Station object
		ds = DriverStation::GetInstance();
		
		ManipulatorDownFlag = false;
		x_l = y_l = x_r = y_r = x_l_prev = y_l_prev = 0.0;
		teleop_state = auto_state = 0;
	}
	
	//! Destructor.  Called when a class object expires.  Used so we don't waste memory.
	~BuiltinDefaultCode()
	{
		delete drive;
		delete controller;
		delete minibotShelf;
		delete manipulatorTop;
		delete manipulatorBottom;
		delete manipulatorElevation;
		delete manipulatorElevationTopLimitSwitch;
		delete manipulatorElevationBottomLimitSwitch;
	}
	
	//! Clean up at end of match.
	void RJRobotEnd(void)
	{
		GetWatchdog().SetExpiration(3.0);
		minibotShelf->Set(Relay::kReverse);
		Wait(2);
		minibotShelf->Set(Relay::kOff);
		manipulatorElevation->Set(Relay::kReverse);
		while (manipulatorElevationBottomLimitSwitch->Get() != 1) { continue; }
		manipulatorElevation->Set(Relay::kOff);
		manipulatorTop->Set(Relay::kOff);
		manipulatorBottom->Set(Relay::kOff);
		drive->Drive(0, 0);
	}
	
	/********************************** Init Routines *************************************/
	
	//! Actions which would be performed once (and only once) upon initialization of the robot are put here
	void RobotInit(void)
	{
		GetWatchdog().SetExpiration(DEFAULT_WATCHDOG_TIME);
		// Actions which would be performed once (and only once) upon initialization of the
		// robot would be put here.
	}
	
	//! Code called at the beginning of Disabled Mode
	void DisabledInit(void)
	{
		GetWatchdog().Feed();
	}
	
	//! Code called at the beginning of Autonomous Mode
	void AutonomousInit(void)
	{
		GetWatchdog().Feed();
		auto_machine->setState(0);
	}
	
	//! Code called at the beginning of Teleoperated Mode
	void TeleopInit(void)
	{
		GetWatchdog().Feed();
		x_l_prev = 0;
		y_l_prev = 0;
	}
	
	/********************************** Periodic Routines *************************************/
	
	//! The code called in a loop during Disabled Mode.  Left as the default, minus the loop counter.
	void DisabledPeriodic(void)
	{
		GetWatchdog().Feed();
		// Basically, sit idle and keep the watchdog running.
	}
	
	//! The code called in a loop during Autonomous Mode
	void AutonomousPeriodic(void)
	{
		GetWatchdog().Feed();
		auto_machine->Go();
		auto_machine->Next();
	}
	
	//! The code called in a loop during Teleoperated Mode
	void TeleopPeriodic(void)
	{
		GetWatchdog().Feed();
		teleop_machine->Go();
		teleop_machine->Next();
		
		// manipulator controls
		if (x_r > 0.35)
		{
			// input tube
		}
		else if (x_r < -0.35)
		{
			// eject tube
		}
		else if ((x_r < 0.35) && (x_r > -0.35))
		{
			manipulatorBottom->Set(Relay::kOff);		// turn things off
			manipulatorTop->Set(Relay::kOff);			// ditto
		}
		
		
		if (ManipulatorDownFlag == true && (x_r < 0.35) && (x_r > -0.35))	// go here ONLY if user has flagged that tube is ready AND the relays are off (done inputting; right joystick has zero X)
		{
			// rotate tube down
		}
		
		// minibot controls
		if (rightSwitch == 1 && leftSwitch == 0)		// 10
		{
			minibotShelf->Set(Relay::kForward);			// Set the relay to forward if the right switch is on...
		}
		else if (leftSwitch == 1 && rightSwitch == 0)	// 01
		{
			minibotShelf->Set(Relay::kReverse);			// ...forward if the left switch is on...
		}
		else if (rightSwitch == 0 && leftSwitch == 0)	// 00
		{
			minibotShelf->Set(Relay::kOff);				// ..or off if the switch is off
		}
		else											// 11
		{
			minibotShelf->Set(Relay::kOff);
		}
		// We back up the shelf in the destructor
		
		// set previous left X and Y values (for ramping function)
		x_l_prev = x_l;
		y_l_prev = y_l;
		Wait(0.1);
	}
	
	//! A function that "ramps" input from a joystick to motors so that an overzealous driver doesn't tear up the chassis
	/*!
	 \param desired_output The output that the operator is trying to send
	 \param current_output The current output
	 \param increment The amount by which to increment ramping.  Defaults to .005
	 \return the ramped value
	 \author Drew Lazzeri
	 */
	float ramp(float desired_output, float current_output)
	{
		float increment = .1;
		if (desired_output  <= .1 && desired_output >= -.1);
		    increment = .05;
		if (desired_output < current_output)
		{
			return current_output - increment;//(desired_output * increment);
		}    
		else if (desired_output > current_output)
		{    
			return /*(desired_output * increment)*/increment + current_output;
		}
		else
		{
			return current_output;
		}
	}
};

START_ROBOT_CLASS(BuiltinDefaultCode);
