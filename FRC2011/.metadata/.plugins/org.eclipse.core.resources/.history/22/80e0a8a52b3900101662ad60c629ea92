/*!
 \file Teleoperated.cpp
 \brief File containing definitions of functions declared in class \a Teleoperated (declared in Teleoperated.h).
 \authors Matthew Haney, Drew Lazzeri
 */

#include "Teleoperated.h"
using namespace RJFRC2011;
/*!
 \brief Construct from a drive system, a manipulator, and a controller.
 \details Set up pointers to passed adresses.  Initialize state and condition pointers.
 */
RJFRC2011::Teleoperated::Teleoperated(Drive * drive, Manipulator * manip, Controller * controller)
{
	this->_drive = drive;
	this->_manip = manip;
	this->_controller = controller;
	this->minibotShelf = new Relay(MINIBOT_SHELF_RELAY_PORT, Relay::kBothDirections);
}

//! Destructor.
RJFRC2011::Teleoperated::~Teleoperated()
{
	delete minibotShelf;
}

/*!
 \brief Set up for Teleoperated mode.
 \details Set all input values to zero.
 */
void RJFRC2011::Teleoperated::init()					// state 0
{
	manipulatorElevation = driveSpeed = driveTurn = manipulatorAction = 0.0;
	minibotSwitches = 0;
	_nextState = 1;
	rotateTubeDownFlag = false;
}

/*!
 \brief Read input from controller.
 \details Store input from controller in local variables, which will be later used in \a getDriverInputCondition().
 */
void RJFRC2011::Teleoperated::getDriverInput()			// state 1
{
	manipulatorElevation = this->_controller->getManipulatorElevation();
	driveSpeed = this->_controller->getDriveSpeed();
	driveTurn = this->_controller->getDriveTurn();
	manipulatorAction = this->_controller->getManipulatorAction();
	minibotSwitches = this->_controller->getMinibotSwitches();
	_nextState = 2;
}

/*!
 \brief Move the robot based on user input.
 \details Basically just a call to \a Drive::drive(speed, turn);
 */
void RJFRC2011::Teleoperated::moveRobot()				// state 2
{
	this->_drive->drive(driveSpeed, driveTurn);
}

/*!
 \brief Elevate the manipulator up or down.
 \details If user is pushing hard left or hard right, elevate accordingly (with \a Manipulator::elevate(val)).  Otherwise, stop the elevation.
 */
void RJFRC2011::Teleoperated::elevateManipulator()		// state 3
{
	if ((manipulatorElevation > 0.35) || (manipulatorElevation < -0.35))
		this->_manip->elevate(manipulatorElevation);
	else
		this->_manip->stopManipulatorElevation();
}

//! Suck in the tube.  Basically a call to \a Manipulator::inputTube().
void RJFRC2011::Teleoperated::inputTube()				// state 4
{
	if (manipulatorAction > 0.35)
	{
		this->_manip->inputTube();
		rotateTubeDownFlag = true;
	}
	else if ((manipulatorAction < 0.35) && (manipulatorAction > -0.35))
	{
		this->_manip->stopManipulatorAction();
	}
}

//! Rotate the tube down.  Basically a call to \a Manipulator::rotateTube().
void RJFRC2011::Teleoperated::rotateTube()				// state 5
{
	if (rotateTubeDownFlag)
	{
		this->_manip->rotateTube();
		rotateTubeDownFlag = false;
		this->_manip->stopManipulatorAction();
	}
}

//! Eject the tube.  Basically a call to \a Manipulator::ejectTube().
void RJFRC2011::Teleoperated::ejectTube()				// state 6
{
	if (manipulatorAction < -0.35)
		this->_manip->ejectTube();
	else if ((manipulatorAction < 0.35) && (manipulatorAction > -0.35))
	{
		this->_manip->stopManipulatorAction();
	}
}

/*!
 \brief Move the minibot shelf.
 \details Based on values of minibot switches, move the shelf in or out (or stop it).
 */
void RJFRC2011::Teleoperated::moveMinibotShelf()		// state 7
{
	if (minibotSwitches == 2)						// 10
	{
		minibotShelf->Set(Relay::kForward);			// Set the relay to forward if the right switch is on...
	}
	else if (minibotSwitches == 1)					// 01
	{
		minibotShelf->Set(Relay::kReverse);			// ...forward if the left switch is on...
	}
	else if (minibotSwitches == 0)					// 00
	{
		minibotShelf->Set(Relay::kOff);				// ..or off if the switch is off
	}
	else//if (minibotSwitches == 3)					// 11
	{
		minibotShelf->Set(Relay::kOff);
	}
}

void RJFRC2011::Teleoperated::Go()
{
	manipulatorElevation = this->_controller->getManipulatorElevation();
	driveSpeed = this->_controller->getDriveSpeed();
	driveTurn = this->_controller->getDriveTurn();
	manipulatorAction = this->_controller->getManipulatorAction();
	minibotSwitches = this->_controller->getMinibotSwitches();
	
	// Move robot
	this->_drive->drive(driveSpeed, driveTurn);
	
	// Elevate manipulator
	if ((manipulatorElevation > 0.35) || (manipulatorElevation < -0.35))
		this->_manip->elevate(manipulatorElevation);
	else
		this->_manip->stopManipulatorElevation();
	
	// Input tube
	if (manipulatorAction > 0.35)
	{
		this->_manip->inputTube();
		rotateTubeDownFlag = true;
	}
	else if ((manipulatorAction < 0.35) && (manipulatorAction > -0.35))
	{
		this->_manip->stopManipulatorAction();
	}
	
	// Rotate tube
	if (rotateTubeDownFlag)
	{
		this->_manip->rotateTube();
		rotateTubeDownFlag = false;
		this->_manip->stopManipulatorAction();
	}
	
	// Eject tube
	if (manipulatorAction < -0.35)
		this->_manip->ejectTube();
	else if ((manipulatorAction < 0.35) && (manipulatorAction > -0.35))
	{
		this->_manip->stopManipulatorAction();
	}
	
	// Move minibot
	if (minibotSwitches == 2)						// 10
	{
		minibotShelf->Set(Relay::kForward);			// Set the relay to forward if the right switch is on...
	}
	else if (minibotSwitches == 1)					// 01
	{
		minibotShelf->Set(Relay::kReverse);			// ...forward if the left switch is on...
	}
	else if (minibotSwitches == 0)					// 00
	{
		minibotShelf->Set(Relay::kOff);				// ..or off if the switch is off
	}
	else//if (minibotSwitches == 3)					// 11
	{
		minibotShelf->Set(Relay::kOff);
	}
}

